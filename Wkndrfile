@foos ||= []

module ProllyNestedMod
end

class ProllyNestedClass
  def cheese
  end
end

module ::MyModule
end

class ::MyClass
end

@foos << ProllyNestedClass.new

log!(:self, Wkndr, self, ::MyModule, ::MyClass, ProllyNestedMod, ProllyNestedClass)
log!(@foos.object_id, @foos)

@foos[0].cheese


##  this is wkndr
#
##  sl.live_index { |conn|
##    #LiveView.Controller.live_render(conn, MyAppWeb.GithubDeployView, session: %{})
##  }
##
##  render_todos = lambda { |assigns|
##
##    mab = Markaby::Builder.new
##    mab.ul do
##      assigns[:todos].each { |todo|
##        mab.li todo
##      }
##    end
##    mab.to_s
##  end
##
##  def mount(socket)
##    :ok, Wkndr.assign(socket, {:todos => []})
##  end
##
##	sl.handle_event("github_deploy", _value, socket) do
##  # do the deploy process
##  {:noreply, assign(socket, deploy_step: "Starting deploy...")}
##end
##  def mount(%{id: id, current_user_id: user_id}, socket) do
##    if connected?(socket), do: :timer.send_interval(30000, self(), :update)
##
##    case Thermostat.get_user_reading(user_id, id) do
##      {:ok, temperature} ->
##        {:ok, assign(socket, temperature: temperature, id: id)}
##
##      {:error, reason} ->
##        {:error, reason}
##    end
##  end
##
##  def handle_info(:update, socket) do
##    {:ok, temperature} = Thermostat.get_reading(socket.assigns.id)
##    {:noreply, assign(socket, :temperature, temperature)}
##  end
## LiveView is first rendered statically as part of regular HTTP requests, which provides quick times for "First Meaningful Paint" and also help search and indexing engines;
## All of the data in a LiveView is stored in the socket as assigns. 
## live_render socket, MyLiveView, container: {:tr, class: "highlight"}
## <button wkndr-click="inc_temperature">+</button>
## Params	phx-value-*
## Click Events	phx-click
## Focus/Blur Events	phx-blur, phx-focus, phx-target
## Form Events	phx-change, phx-submit, data-phx-error-for, phx-disable-with
## Key Events	phx-keydown, phx-keyup, phx-target
## Rate Limiting	phx-debounce, phx-throttle
## Custom DOM Patching	phx-update
## JS Interop	phx-hook
##Any number of optional phx-value- prefixed attributes, such as:
##
##<div phx-click="inc" phx-value-myvar1="val1" phx-value-myvar2="val2">
##
##will send the following map of params to the server:
##
##def handle_event("inc", %{"myvar1" => "val1", "myvar2" => "val2"}, socket) do
##def error_tag(form, field) do
##  Enum.map(Keyword.get_values(form.errors, field), fn error ->
##    content_tag(:span, translate_error(error),
##      class: "help-block",
##      data: [phx_error_for: input_id(form, field)]
##    )
##  end)
##end
##def render(assigns) ...
##
##def mount(_session, socket) do
##  {:ok, assign(socket, %{changeset: Accounts.change_user(%User{})})}
##end
##
##def handle_event("validate", %{"user" => params}, socket) do
##  changeset =
##    %User{}
##    |> Accounts.change_user(params)
##    |> Map.put(:action, :insert)
##
##  {:noreply, assign(socket, changeset: changeset)}
##end
##
##def handle_event("save", %{"user" => user_params}, socket) do
##  case Accounts.create_user(user_params) do
##    {:ok, user} ->
##      {:stop,
##       socket
##       |> put_flash(:info, "user created")
##       |> redirect(to: Routes.user_path(AppWeb.Endpoint, AppWeb.User.ShowView, user))}
##
##    {:error, %Ecto.Changeset{} = changeset} ->
##      {:noreply, assign(socket, changeset: changeset)}
##  end
##end
#
#class TodoLive
#  def index
#  end
#
#### ??? handle_call(msg, from, socket)
#### ??? terminate(reason, socket)
###handle_event(event, unsigned_params, socket) # from client
###handle_info(msg, socket) # like handle event, but from internal event source
###handle_params(unsigned_params, uri, socket) # from internal re-routing of queryString params, like sort filter
###mount(session, socket)
###render(assigns)
#
#end
#
#
#Wkndr.camp { |sl|
#	
#
#  sl.get('/bloops') { |ids_from_path|
#	}
#
#  sl.get('/todos') { |ids_from_path|
#    mab = Markaby::Builder.new
#    mab.html5 {
#      mab.head { mab.title "TODOS" }
#      mab.body {
#        mab.h1 "TODOS"
#        sl.live(mab, render_todos, )
#      }
#    }
#    bytes_to_return = mab.to_s
#  }
#
#  sl.get('/boats') { |ids_from_path|
#    mab = Markaby::Builder.new
#    mab.html5 do
#      mab.head { mab.title "Boats.com" }
#      mab.body do
#        mab.h1 "Boats.com has great deals"
#        mab.ul do
#          mab.li "$2.99 for a canoe"
#          mab.li "$3.99 for a raft"
#          mab.li "$4.99 for a huge boat that floats and can fit 5 people"
#        end
#      end
#    end
#    bytes_to_return = mab.to_s
#  }
#}
#
#Wkndr.play { |gl|
#  gl.lookat(1, 11.0, 7.0, 13.0, 0.0, 0.0, 0.01, 15.0)
#
#  total_msg = 0
#
#  cubes = []
#  cubes << Cube.new(0.13, 0.70, 0.15, 1.00)
#  cubes << Cube.new(0.17, 0.30, 0.90, 1.00)
#  cubes << Cube.new(1.10, 0.19, 0.40, 1.00)
#
#  gl.event { |typed_msg|
#    total_msg += 1
#  }
#
#  gl.update { |global_time, delta_time|
#    speed = 100.0 # + (global_time * 10.0)
#
#    gl.drawmode {
#      gl.threed {
#        cubes.each_with_index do |cube,i|
#          cube.deltar(Math.cos((i+1)*-global_time), Math.sin((i+1) * global_time), 1.0, global_time * speed)
#          #cube.deltar(0.5, 0, 1, global_time * speed)
#          cube.draw(true)
#        end
#      }
#
#      gl.twod {
#        gl.button(50.0, 50.0, 250.0, 20.0, "login test #{total_msg}/#{'%0.2f' % global_time}") {
#          gl.emit({"c" => "tty"})
#        }
#      }
#    }
#  }
#}
#
##Implementation
##Concepts
##
##    Entity: An integer.
##    Entity Manager: A singleton class.
##    Component: A class with data.
##    System: A generic class with methods and an object array.
##    Component System: A singleton class that extends System using a specific Component class.
##
##Duties
##
##    Entity: A handle shared by all systems. It has no idea what components it has.
##    Entity Manager: Prevents duplicate IDs from being handed out. Recycles IDs that have been removed from all component systems. Handles the removal of an entity from all component systems.
##    Component: Holds data of a specific type. If things get dirty (as rapid game development often does), it can have methods for other systems to work with that data, such as a vector class that can return its magnitude.
##    System: (This is a generic class, and never used directly) Manage an array of Components of a specified class, using the value of Entity as an index. Has methods to add, update, get, remove, and process that data.
##    Component System: Extends System with the Component's class. Almost always overrides the Process function.
##
##Expansion
##
##Out of the box, it is only possible to process (or try to process) every object, in every system, each frame. But the framework also allows a system to process individual entities. This could lead to a "group" class that manages its own list of entity ID's, preventing wasted cycles on "blank" entries in systems. It would still use the Entity Manager to create and destroy entities.
##
##
