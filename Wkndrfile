# vi:syntax=ruby

@one_position = [0.0, 1.0, 0.0]
@two_position = [-5.0, -5.0, 0.0]
@three_position = [5.0, 5.0, 0.0]

@one_target = [0.0, 0.0]
@two_target = [0.0, 0.0]
@three_target = [0.0, 0.0]

def centroid(coords)
  #x_sum = 0.0
  #y_sum = 0.0
  #len = 0.0

  #coords.each do |coord|
  #  x_sum += coord[0]
  #  y_sum += coord[1]
  #  len += 1.0
  #end

  #rx = x_sum / len
  #ry = y_sum / len


  #centroid_lat = 0.0
  #centroid_lng = 0.0
  #signed_area = 0.0

  ## Iterate over each element in the list but the last item as it's
  ## calculated by the i+1 logic
  #coords[0...-1].each_index do |i|
  #  x0 = coords[i][0]
  #  y0 = coords[i][1]
  #  x1 = coords[i + 1][0]
  #  y1 = coords[i + 1][1]
  #  a = (x0 * y1) - (x1 * y0)
  #  signed_area += a
  #  centroid_lat += (x0 + x1) * a
  #  centroid_lng += (y0 + y1) * a
  #end

  #signed_area *= 0.5
  #centroid_lat /= (6.0 * signed_area)
  #centroid_lng /= (6.0 * signed_area)

  #return [centroid_lat, centroid_lng]

  [
   (coords[0][0] + coords[1][0] + coords[2][0])/3.0,
   (coords[0][1] + coords[1][1] + coords[2][1])/3.0
  ]
end

xloop(:a) { |recycle_msg|
  d = 10.0
  hd = d * 0.5
  case recycle_msg[:msg]
    when :restart
      @one_target[0] = (rand * d) - hd
      @one_target[1] = (rand * d) - hd
      xleap :idle, 1.1

      @two_target[0] = (rand * d) - hd
      @two_target[1] = (rand * d) - hd
      xleap :idle, 1.1

      @three_target[0] = (rand * d) - hd
      @three_target[1] = (rand * d) - hd
      xleap :restart, 1.1

  end
}

Wkndr.nonce("main") {
  $ticks = 0

  Wkndr.client_side("main") { |gl|
    gl.open_default_view!
  }
}

$speed = 64.0

Wkndr.client_side("main") { |gl|
  a = Cube.new(gl, 1.0, 1.0, 1.0, 1.0)
  b = Cube.new(gl, 1.0, 1.0, 1.0, 1.0)
  c = Cube.new(gl, 1.0, 1.0, 1.0, 1.0)

  frame_count = 0
  running_average = 0.0

  all_positions = [@one_position, @two_position, @three_position]

  gl.update("main") { |global_time, delta_time, sw, sh, touchpoints|
    #log!(:touchpoints, touchpoints)

    mx, my, l = nil

    gl.mousep { |xyl|
      mx, my, l = *xyl
    }

    hsw = (sw * 0.5).to_f
    hsh = (sh * 0.5).to_f

    fiberz(global_time)

    @one_position[0] -= (@one_position[0] - @one_target[0]) * 0.7 * delta_time
    @one_position[1] -= (@one_position[1] - @one_target[1]) * 0.7 * delta_time

    @two_position[0] -= (@two_position[0] - @two_target[0]) * 0.7 * delta_time
    @two_position[1] -= (@two_position[1] - @two_target[1]) * 0.7 * delta_time

    @three_position[0] -= (@three_position[0] - @three_target[0]) * 0.7 * delta_time
    @three_position[1] -= (@three_position[1] - @three_target[1]) * 0.7 * delta_time

    a.deltap(@one_position[0], @one_position[1], 0.0)
    b.deltap(@two_position[0], @two_position[1], 0.0)
    c.deltap(@three_position[0], @three_position[1], 0.0)

    gl.drawmode {
      gl.threed {
        gl.lookat(1, 0.0, 0.0, 25.0, 0.0, 0.1, 0.0, 60.0)

        a.draw(false)
        b.draw(false)
        c.draw(false)
      }

      gl.twod {
        frame_count += 1
        running_average += delta_time
        fps = (1.0 / (running_average / frame_count.to_f))
        center_of_boxes = centroid(all_positions)
        sx, sy = gl.screenat(center_of_boxes[0], center_of_boxes[1], 0)
        gl.draw_circle(5.0, sx, sy, 0.0, 255.0, 128.0, 64.0, 255.0)
        if touchpoints.length == 3
          touchpoints.each { |tx, ty|
            gl.draw_circle(100.0, tx, ty, 0.0, 32.0, 32.0, 255.0, 255.0)
          }
          center_of_touches = centroid(touchpoints)
          gl.draw_circle(20.0, center_of_touches[0], center_of_touches[1], 0.0, 128.0, 32.0, 192.0, 255.0)
        end
        gl.draw_circle(50.0, mx, my, 0.0, 32.0, 128.0, 128.0, 255.0)
        gl.label(sx, sy, "%d %3.3f %3.3f %3.0f" % [frame_count, global_time, delta_time, fps])
      }
    }
  }
}


Wkndr.server_side("main") { |gl, server|
  server.wsb("/") do |cn, phr|
  end

  server.raw("/status") do |cn, phr|
    Protocol.ok("ONLINE\n") #TODO: present SHA1 of existing code somehow?????
  end

  server.raw("/about") do |cn, phr|
    mab = Markaby::Builder.new
    mab.html5 "lang" => "en" do
      mab.head do
        mab.title "about"
      end

      mab.body do
        mab.h1 "what is wkndr"
        mab.p "it is a new hypertext application platform"
        mab.a "href" => "/" do
          "//////"
        end
      end
    end
    Protocol.ok(mab.to_s)
  end
}
