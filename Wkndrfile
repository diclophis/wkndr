# vi:syntax=ruby

class SpinComponent
  def initialize(index, speed)
    @index = index
    @speed = speed
  end

  def index
    @index
  end

  def speed
    @speed
  end
end

#class CubicBatchingSystem
##  def initialize(store, count, mesh)
##    @store = store
##    @count = count
##    @mesh = mesh
##    @proxies = []
##    hydrate
##  end
##
#  def at(i)
#    @model
##    #@mesh_proxies[i]
##    # this reaches into instance variable bits
##    #AssignmentProxy
##    mp = MeshProxy.new(@transforms[]...) # feeds transform at index
##    #mp.deltap ####!!!! mp becomes cube replacement
##    #mp.deltar
#  end
##
##  def foopity
##    #before flush
##    #each required instance transform update is looped via 
##    ## this can be saved via at above!!!??
##    #  passing proxybaseinstancemod into c-sided base batchingclass
##    #    update_instance_transform
##    @proxies.each { |p|
##      
##    }
##
##  end
#end

class GizmoSystem
  def initialize(store, selector)
    @selector = selector
  end

  def process(gt, dt)
    @selector.each { |_e, cube, pos, spin|
      #cube.deltar(
      #  Math.cos((spin.index)*-gt), Math.sin((spin.index) * gt), 1.0, gt * spin.speed
      #)
      cube.deltap(pos.x, pos.y, pos.z)
    }
  end
end

Wkndr.nonce {
  Wkndr.client_side { |gl|
    gl.open_default_view!
    gl.lookat(1, 11.0, 7.0, 13.0, 0.0, 0.0, 0.01, 15.0)

    @store = StorageManager.new
    @transformer = TransformerSystem.new(@store)
    @exhaust = ExhaustSystem.new(@store, 0.025, @particleBitmap, @particleLayer)
    @movement = MovementSystem.new(@store)
    @exhaust_layer = @store.watch(ExhaustComponent, PositionComponent, RandomColorComponent)
    @hunter_layer = @store.watch(HunterComponent, PositionComponent, RandomColorComponent)
    @color = RandomColorComponent.new

    @last_l = 0

    @spawn_proc = Proc.new { |r, x, y, c|
      @store.add(
        HunterComponent.new(r),
        PositionComponent.new(x, y, 0),
        VelocityComponent.from_angle(r * 2.0 * 3.14).mul(500.0),
        SpriteComponent.new,
        TransformComponent.new(1.0),
        RandomColorComponent.from_color(c)
      )
    }

    @spinny_things = @store.watch(MeshProxy, PositionComponent, SpinComponent)
    @gizmo = GizmoSystem.new(@store, @spinny_things)

    #a = Cube.new(gl, 0.13, 0.67, 0.15, 1.00)
    #b = Cube.new(gl, 0.23, 0.37, 0.97, 1.00)
    #c = Cube.new(gl, 1.13, 0.19, 0.41, 1.00)

    am = Cube.new(gl, 0.13, 0.67, 0.15, 1.00)
    bm = Cube.new(gl, 0.23, 0.37, 0.97, 1.00)
    cm = Cube.new(gl, 1.13, 0.19, 0.41, 1.00)

    # each of abc by 9 grid

    count = 1

    @batcher_a = CubicBatchingSystem.new(@store, am, count)
    @batcher_b = CubicBatchingSystem.new(@store, bm, count)
    @batcher_c = CubicBatchingSystem.new(@store, cm, count)

    count.times { |i|
      p = PositionComponent.new(i * 0.33, i * -0.33, 0)
      #p = PositionComponent.new(0, 0, 0)

      @store.add(
        @batcher_a.at(i),
        #a = Cube.new(gl, 0.13, 0.67, 0.15, 1.00),
        p,
        SpinComponent.new(3.0, 1.0)
      )

      @store.add(
        @batcher_b.at(i),
        #b = Cube.new(gl, 0.23, 0.37, 0.97, 1.00),
        p,
        SpinComponent.new(5.0, 5.0)
      )

      @store.add(
        @batcher_c.at(i),
        #c = Cube.new(gl, 1.13, 0.19, 0.41, 1.00),
        p,
        SpinComponent.new(7.0, 10.0)
      )
    }
  }

  Wkndr.server_side { |gl|
    @ticks = 0
  }
}

Wkndr.client_side { |gl|
  gl.event { |channel, msg|
    case channel
      when "spawn"
        @spawn_proc.call(*msg) if (@spawn_proc && @store)
    end
  }

  gl.update { |global_time, delta_time, sw, sh|
    gl.mousep { |xyl|
      x, y, l = *xyl

      if (l == 1 && @last_l == 0)
        3.times {
          spawn_proc_args = [
            rand,
            x,
            y,
            @color.color
          ]

          @spawn_proc.call(*spawn_proc_args)
          gl.emit({"spawn" => spawn_proc_args})
        }
      end

      @last_l = l
    }

    gl.drawmode {
      gl.threed {
        @batcher_a.draw
      }

      gl.twod {
        @exhaust_layer.each { |e, _x, p, c|
          gl.draw_circle(10.0, p.x, p.y, p.z, *c.color)
        }

        @hunter_layer.each { |e, _h, p, c|
          gl.draw_circle(20.0, p.x, p.y, p.z, *c.color)
        }
      }
    }

    @transformer.process(global_time, delta_time)
    @exhaust.process(global_time, delta_time)
    @movement.process(global_time, delta_time)
    @gizmo.process(global_time, delta_time)
  }
}

Wkndr.server_side { |gl, server|
  server.wsb("/") do |cn, phr|
  end

  server.raw("/status") do |cn, phr|
    Protocol.ok("ONLINE\n") #TODO: present SHA1 of existing code somehow?????
  end


  server.raw("/about") do |cn, phr|
    mab = Markaby::Builder.new
    mab.html5 "lang" => "en" do
      mab.head do
        mab.title "about"
      end

      mab.body do
        mab.h1 "what is wkndr"
        mab.p "it is a new hypertext application platform"
      end
    end
    Protocol.ok(mab.to_s)
  end

  server.live("/sevengui", "wkndr sevengui") { |cn, phr, mab|
    mab.a(:href => "/sevengui") do
      mab.h1 "sevengui example"
    end

    mab.ul do
      mab.li do
        "bap bar: " + cn.session["gt"].inspect
      end
    end
  }
}
